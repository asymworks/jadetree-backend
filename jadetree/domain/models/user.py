"""Jade Tree User Domain Model.

Jade Tree Personal Budgeting Application | jadetree.io
Copyright (c) 2020 Asymworks, LLC.  All Rights Reserved.
"""

from dataclasses import dataclass
from hashlib import blake2s

from arrow import Arrow, utcnow
from babel.numbers import format_currency, format_decimal
from werkzeug.security import check_password_hash, generate_password_hash

from ..mixins import TimestampMixin

__all__ = ('User', )


@dataclass
class User(TimestampMixin):
    """Holds user information for a Jade Tree user.

    Users can also set preferences for language, default currency, and
    formatting for numbers, currency, dates, and times.  Custom formatting
    strings can be provided, which override the locale defaults.  Locale data
    comes from `Babel`_, and all custom formatting strings must comply with
    `Unicode LDML`_.

    .. _`Babel`: http://babel.pocoo.org/en/latest/

    .. _`Unicode LDML`:
        https://unicode.org/reports/tr35/#Number_Format_Patterns

    .. py:attribute:: email
        :type: str

        Email address for the user, which must be a valid email address. This
        will be the primary user identifier for signing in interactively.

    .. py:attribute:: pw_hash
        :type: str

        Hashed password for the user, which is hashed using
        :func:`werkzeug.security.generate_password_hash`.  Plain text password
        data is never stored in the database.

    .. py:attribute:: uid_hash
        :type: str

        Unique identifier for the user, which is generated by hashing the
        email address and a timestamp using the :func:`python:hashlib.blake2s`
        hashing function. This value is used to store the user identifier for
        stored sessions and authorization tokens, so that existing sessions
        may be invalidated by changing the hash, forcing users to log in
        again with password. This functionality is used when e.g. the user
        changes their password.

    .. py:attribute:: active
        :type: bool

        Flag indicating whether the user account is active or not.  Inactive
        accounts can not log in and access account information, but may be
        kept in the system.  After registration, the account is initially set
        as invalid, pending the user's confirmation of their registration.

    .. py:attribute:: confirmed
        :type: bool

        Flag indicating whether the user account details have been confirmed
        or not. This flag is set to false when the account is registered, and
        an email is sent to the provided email address prompting the user to
        confirm that the email address is correct. When the user clicks the
        provided link and sends a token back to the server to confirm their
        account, this flag is set to True.

        This attribute is generally immutable after the user has confirmed
        their registration.

    .. py:attribute:: confirmed_at
        :type: datetime

        Date and time that the user confirmed their registration. Native type
        is an :py:class:`Arrow <arrow:arrow.arrow.Arrow>` object using the
        :py:class:`jadetree.models.types.ArrowType` column type.

        This attribute is generally immutable after the user has confirmed
        their registration.

    .. py:attribute:: profile_setup
        :type: bool

        Flag indicating whether the user profile preferences have been set
        following initial registration. When the user has selected their
        default locale and currency preferences, this flag will be set to
        True.

        This attribute is generally immutable after the user has initially
        selected their profile preferences.

    .. py:attribute:: profile_setup_at
        :type: datetime

        Date and time that the user set their profile preferences. Native type
        is an :py:class:`Arrow <arrow:arrow.arrow.Arrow>` object using the
        :py:class:`jadetree.models.types.ArrowType` column type.

        This attribute is generally immutable after the user has initially
        selected their profile preferences.

    .. py:attribute:: language
        :type: str

        Language code for the user interface. This is used to select the
        translation files for the interface, but does not affect localized
        formatting routines.

    .. py:attribute:: locale
        :type: str

        Locale string for the user's default locale. This is used to select
        formatting strings if they are not overridden by the user. The locale
        string should use underscore separators and should at least include
        the language and territory tags (e.g. en_US), but may be any valid
        locale string that :mod:`babel` can load.

    .. py:attribute:: currency
        :type: str

        Currency code for the user's default currency. This is used as the
        initial currency for new account setups, but may be overridden by the
        user on a per-account and per-transaction basis. This is a three-digit
        ISO 4217 code (e.g. 'USD').

    .. py:attribute:: fmt_date_short
        :type: str

        If set to a string, this overrides the default short date format
        string for the locale. Must be a valid format string complying with
        `Unicode LDML`_.

    .. py:attribute:: fmt_date_long
        :type: str

        If set to a string, this overrides the default long date format
        string for the locale. Must be a valid format string complying with
        `Unicode LDML`_.

    .. py:attribute:: fmt_decimal
        :type: str

        If set to a string, this overrides the default decimal number format
        string for the locale. Must be a valid format string complying with
        `Unicode LDML`_.

    .. py:attribute:: fmt_currency
        :type: str

        If set to a string, this overrides the default currency amount format
        string for the locale. Must be a valid format string complying with
        `Unicode LDML`_.

    .. py:attribute:: fmt_accounting
        :type: str

        If set to a string, this overrides the default accounting format
        string for the locale. Must be a valid format string complying with
        `Unicode LDML`_.

    """
    __hash__ = object.__hash__

    email: str = None
    pw_hash: str = None
    uid_hash: str = None

    # User Roles
    admin: bool = None

    # Active and Confirmation Status
    active: bool = None
    confirmed: bool = None
    confirmed_at: Arrow = None
    profile_setup: bool = None
    profile_setup_at: Arrow = None

    # Profile Settings
    name: str = None
    language: str = None
    locale: str = None
    currency: str = None

    # Formatting Overrides (Dates)
    fmt_date_short: str = None
    fmt_date_long: str = None

    # Formatting Overrides (Numbers)
    fmt_decimal: str = None
    fmt_currency: str = None
    fmt_accounting: str = None

    # Populated by ORM
    # accounts: List['Account'] = field(default_factory=list)     # noqa: F821
    # budgets: List['Budget'] = field(default_factory=list)       # noqa: F821

    # Domain Logic
    def _generate_user_hash(self):
        """Create a new User Hash for the user_id field."""
        ts = f'{utcnow()}'.encode('ascii')
        h = blake2s(digest_size=16)
        h.update(self.email.encode('ascii'))
        h.update(ts)
        return h.hexdigest()

    def check_password(self, pw):
        """Check if the provided password matches the user's."""
        return check_password_hash(self.pw_hash, pw)

    def format_decimal(self, amount, currency=None, accounting=False):
        """Format a decimal number.

        Format the given amount as decimal, currency, or accounting. If the
        currency parameter is None, the number will be formatted as a standard
        decimal number; otherwise, it will be formatted as currency or as an
        accounting value per the accounting parameter.
        """
        if currency is None:
            return format_decimal(
                amount,
                format=self.fmt_numeric,
                locale=self.locale,
                decimal_quantization=False,
            )
        else:
            fmt = self.fmt_accounting if accounting else self.fmt_currency
            return format_currency(
                amount,
                currency,
                format=fmt,
                locale=self.locale,
                format_type='accounting' if accounting else 'standard'
            )

    def set_password(self, pw, update_hash=True):
        """Set the User's Password.

        Change or set the user password and create a new user hash so that
        any login tokens referencing the current user will be invalidated and
        the sessions must log in again with the new password. Set the
        `update_hash` parameter to false to keep all sessions logged in.

        Args:
            pw: new password
            update_hash: Optional; If update_hash is False, the user uid_hash
                will not be updated, and all currently logged in sessions can
                continue. The default is to update the uid_hash value so that
                all currently logged in sessions are required to log in again
                with the new password.
        """
        self.pw_hash = generate_password_hash(pw)
        if update_hash:
            self.uid_hash = self._generate_user_hash()

    # Login Helpers
    def get_id(self):
        """Return a unique User Id Hash."""
        return self.uid_hash

    @property
    def has_profile(self):
        """Check if the User's Profile is set up."""
        return self.profile_setup

    @property
    def is_active(self):
        """Check if a User object is active."""
        return self.active

    @property
    def is_anonymous(self):
        """Check if a User object is an anonymous user."""
        return False

    @property
    def is_authenticated(self):
        """Check if a User object is an authenticated user."""
        return True

    # Helpers
    def __eq__(self, other):
        """Checks the equality of two `User` objects using :meth:`get_id`."""
        if isinstance(other, User):
            return self.get_id() == other.get_id()
        return NotImplemented

    def __ne__(self, other):
        """Checks the inequality of two `User` objects using :meth:`get_id`."""
        equal = self.__eq__(other)
        if equal is NotImplemented:
            return NotImplemented
        return not equal

    def __repr__(self):
        """Return a string representation of the User."""
        return '<User {} [{}]>'.format(
            self.name,
            self.email
        )
